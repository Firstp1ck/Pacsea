//! PTY-based command executor for in-TUI execution.

use crate::state::{PackageItem, modal::CascadeMode};

/// What: Request types for command execution.
///
/// Inputs:
/// - Various operation types (Install, Remove, etc.) with their parameters.
///
/// Output:
/// - Sent to executor worker to trigger command execution.
///
/// Details:
/// - Each variant contains all necessary information to build and execute the command.
#[derive(Debug, Clone)]
pub enum ExecutorRequest {
    /// Install packages.
    Install {
        /// Packages to install.
        items: Vec<PackageItem>,
        /// Optional sudo password for official packages.
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Remove packages.
    Remove {
        /// Package names to remove.
        names: Vec<String>,
        /// Optional sudo password.
        password: Option<String>,
        /// Cascade removal mode.
        cascade: CascadeMode,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    // Future: Update, Scan, Downgrade, etc.
}

/// What: Output messages from command execution.
///
/// Inputs:
/// - Generated by executor worker during command execution.
///
/// Output:
/// - Sent to main event loop for display in `PreflightExec` modal.
///
/// Details:
/// - Line messages contain output from the `PTY`, Finished indicates completion.
#[derive(Debug, Clone)]
pub enum ExecutorOutput {
    /// Output line from command execution.
    Line(String),
    /// Replace the last line (used for progress bars with carriage return).
    ReplaceLastLine(String),
    /// Command execution finished.
    Finished {
        /// Whether execution succeeded.
        success: bool,
        /// Exit code if available.
        exit_code: Option<i32>,
    },
    /// Error occurred during execution.
    Error(String),
}

/// What: Build install command string without hold tail for `PTY` execution.
///
/// Inputs:
/// - `items`: Packages to install.
/// - `_password`: Optional sudo password (unused - password is written to PTY stdin when sudo prompts).
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail).
///
/// Details:
/// - Groups official and `AUR` packages separately.
/// - Uses `--noconfirm` for non-interactive execution.
/// - Always uses `sudo -S` for official packages (password written to PTY stdin when sudo prompts).
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_install_command_for_executor(
    items: &[PackageItem],
    password: Option<&str>,
    dry_run: bool,
) -> String {
    use super::command::aur_install_body;
    use super::utils::shell_single_quote;
    use crate::state::Source;

    let mut official: Vec<String> = Vec::new();
    let mut aur: Vec<String> = Vec::new();

    for item in items {
        match item.source {
            Source::Official { .. } => official.push(item.name.clone()),
            Source::Aur => aur.push(item.name.clone()),
        }
    }

    if dry_run {
        if !aur.is_empty() {
            let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
            format!(
                "echo DRY RUN: (paru -S --needed --noconfirm {n} || yay -S --needed --noconfirm {n})",
                n = all.join(" ")
            )
        } else if !official.is_empty() {
            format!(
                "echo DRY RUN: sudo pacman -S --needed --noconfirm {n}",
                n = official.join(" ")
            )
        } else {
            "echo DRY RUN: nothing to install".to_string()
        }
    } else if !aur.is_empty() {
        let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
        let n = all.join(" ");
        aur_install_body("-S --needed --noconfirm", &n)
    } else if !official.is_empty() {
        let base_cmd = format!("pacman -S --needed --noconfirm {}", official.join(" "));
        // Use printf to pipe password to sudo -S (more reliable than echo)
        password.map_or_else(
            || format!("sudo {base_cmd}"),
            |pass| {
                let escaped = shell_single_quote(pass);
                format!("printf '%s\\n' {escaped} | sudo -S {base_cmd}")
            },
        )
    } else {
        "echo nothing to install".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::Source;

    /// What: Create a test package item with specified source.
    ///
    /// Inputs:
    /// - `name`: Package name
    /// - `source`: Package source (Official or AUR)
    ///
    /// Output:
    /// - PackageItem ready for testing
    ///
    /// Details:
    /// - Helper to create test packages with consistent structure
    fn create_test_package(name: &str, source: Source) -> PackageItem {
        PackageItem {
            name: name.into(),
            version: "1.0.0".into(),
            description: String::new(),
            source,
            popularity: None,
            out_of_date: None,
            orphaned: false,
        }
    }

    #[test]
    /// What: Verify executor command builder creates correct commands without hold tail.
    ///
    /// Inputs:
    /// - Official and AUR packages.
    /// - Optional password.
    /// - Dry-run flag.
    ///
    /// Output:
    /// - Commands without hold tail, suitable for PTY execution.
    ///
    /// Details:
    /// - Ensures commands are properly formatted and don't include terminal hold prompts.
    fn executor_build_install_command_variants() {
        let official_pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        let aur_pkg = create_test_package("yay-bin", Source::Aur);

        // Official package without password
        let cmd1 =
            build_install_command_for_executor(std::slice::from_ref(&official_pkg), None, false);
        assert!(cmd1.contains("sudo pacman -S --needed --noconfirm ripgrep"));
        assert!(!cmd1.contains("Press any key to close"));

        // Official package with password
        let cmd2 = build_install_command_for_executor(
            std::slice::from_ref(&official_pkg),
            Some("pass"),
            false,
        );
        assert!(cmd2.contains("printf "));
        assert!(cmd2.contains("sudo -S pacman -S --needed --noconfirm ripgrep"));

        // AUR package
        let cmd3 = build_install_command_for_executor(std::slice::from_ref(&aur_pkg), None, false);
        assert!(cmd3.contains("command -v paru"));
        assert!(!cmd3.contains("Press any key to close"));

        // Dry run
        let cmd4 = build_install_command_for_executor(&[official_pkg], None, true);
        assert!(cmd4.starts_with("echo DRY RUN:"));
    }

    #[test]
    /// What: Verify command builder handles mixed official and AUR packages.
    ///
    /// Inputs:
    /// - Mixed list of official and AUR packages.
    ///
    /// Output:
    /// - Command that installs all packages using appropriate tool.
    ///
    /// Details:
    /// - When AUR packages are present, command should use AUR helper for all packages.
    fn executor_build_mixed_packages() {
        let official_pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );
        let aur_pkg = create_test_package("yay-bin", Source::Aur);

        let cmd = build_install_command_for_executor(&[official_pkg, aur_pkg], None, false);
        // When AUR packages are present, should use AUR helper
        assert!(cmd.contains("command -v paru") || cmd.contains("command -v yay"));
    }

    #[test]
    /// What: Verify command builder handles empty package list.
    ///
    /// Inputs:
    /// - Empty package list.
    ///
    /// Output:
    /// - Command that indicates nothing to install.
    ///
    /// Details:
    /// - Empty list should produce a safe no-op command.
    fn executor_build_empty_list() {
        let cmd = build_install_command_for_executor(&[], None, false);
        assert!(cmd.contains("nothing to install") || cmd.is_empty());
    }

    #[test]
    /// What: Verify command builder handles multiple official packages.
    ///
    /// Inputs:
    /// - Multiple official packages.
    ///
    /// Output:
    /// - Command that installs all packages via pacman.
    ///
    /// Details:
    /// - Multiple packages should be space-separated in the command.
    fn executor_build_multiple_official() {
        let pkg1 = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );
        let pkg2 = create_test_package(
            "fd",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        let cmd = build_install_command_for_executor(&[pkg1, pkg2], None, false);
        assert!(cmd.contains("ripgrep"));
        assert!(cmd.contains("fd"));
        assert!(cmd.contains("pacman -S --needed --noconfirm"));
    }

    #[test]
    /// What: Verify dry-run mode produces echo commands.
    ///
    /// Inputs:
    /// - Package list with `dry_run=true`.
    ///
    /// Output:
    /// - Command that starts with "echo DRY RUN:".
    ///
    /// Details:
    /// - Dry-run should never execute actual install commands.
    fn executor_build_dry_run() {
        let pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        let cmd = build_install_command_for_executor(&[pkg], None, true);
        assert!(cmd.starts_with("echo DRY RUN:"));
        // In dry-run mode, the command is wrapped in echo, so it may contain the original command text
        // The important thing is that it starts with "echo DRY RUN:" which prevents execution
    }

    #[test]
    /// What: Verify password is properly escaped in command.
    ///
    /// Inputs:
    /// - Official package with password containing special characters.
    ///
    /// Output:
    /// - Command with properly escaped password.
    ///
    /// Details:
    /// - Password should be single-quoted to prevent shell injection.
    fn executor_build_password_escaping() {
        let pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        // Password with special characters
        let password = "pass'word\"with$special";
        let cmd = build_install_command_for_executor(&[pkg], Some(password), false);
        assert!(cmd.contains("printf"));
        assert!(cmd.contains("sudo -S"));
        // Password should be properly quoted
        assert!(cmd.contains('\'') || cmd.contains('"'));
    }
}
