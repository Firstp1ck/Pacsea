//! PTY-based command executor for in-TUI execution.

use crate::state::{PackageItem, modal::CascadeMode};

/// What: Request types for command execution.
///
/// Inputs:
/// - Various operation types (Install, Remove, etc.) with their parameters.
///
/// Output:
/// - Sent to executor worker to trigger command execution.
///
/// Details:
/// - Each variant contains all necessary information to build and execute the command.
#[derive(Debug, Clone)]
pub enum ExecutorRequest {
    /// Install packages.
    Install {
        /// Packages to install.
        items: Vec<PackageItem>,
        /// Optional sudo password for official packages.
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Remove packages.
    Remove {
        /// Package names to remove.
        names: Vec<String>,
        /// Optional sudo password.
        password: Option<String>,
        /// Cascade removal mode.
        cascade: CascadeMode,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    // Future: Update, Scan, Downgrade, etc.
}

/// What: Output messages from command execution.
///
/// Inputs:
/// - Generated by executor worker during command execution.
///
/// Output:
/// - Sent to main event loop for display in `PreflightExec` modal.
///
/// Details:
/// - Line messages contain output from the `PTY`, Finished indicates completion.
#[derive(Debug, Clone)]
pub enum ExecutorOutput {
    /// Output line from command execution.
    Line(String),
    /// Replace the last line (used for progress bars with carriage return).
    ReplaceLastLine(String),
    /// Command execution finished.
    Finished {
        /// Whether execution succeeded.
        success: bool,
        /// Exit code if available.
        exit_code: Option<i32>,
    },
    /// Error occurred during execution.
    Error(String),
}

/// What: Build install command string without hold tail for `PTY` execution.
///
/// Inputs:
/// - `items`: Packages to install.
/// - `_password`: Optional sudo password (unused - password is written to PTY stdin when sudo prompts).
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail).
///
/// Details:
/// - Groups official and `AUR` packages separately.
/// - Uses `--noconfirm` for non-interactive execution.
/// - Always uses `sudo -S` for official packages (password written to PTY stdin when sudo prompts).
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_install_command_for_executor(
    items: &[PackageItem],
    password: Option<&str>,
    dry_run: bool,
) -> String {
    use super::command::aur_install_body;
    use super::utils::shell_single_quote;
    use crate::state::Source;

    let mut official: Vec<String> = Vec::new();
    let mut aur: Vec<String> = Vec::new();

    for item in items {
        match item.source {
            Source::Official { .. } => official.push(item.name.clone()),
            Source::Aur => aur.push(item.name.clone()),
        }
    }

    if dry_run {
        if !aur.is_empty() {
            let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
            format!(
                "echo DRY RUN: (paru -S --needed --noconfirm {n} || yay -S --needed --noconfirm {n})",
                n = all.join(" ")
            )
        } else if !official.is_empty() {
            format!(
                "echo DRY RUN: sudo pacman -S --needed --noconfirm {n}",
                n = official.join(" ")
            )
        } else {
            "echo DRY RUN: nothing to install".to_string()
        }
    } else if !aur.is_empty() {
        let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
        let n = all.join(" ");
        aur_install_body("-S --needed --noconfirm", &n)
    } else if !official.is_empty() {
        let base_cmd = format!("pacman -S --needed --noconfirm {}", official.join(" "));
        // Use printf to pipe password to sudo -S (more reliable than echo)
        password.map_or_else(
            || format!("sudo {base_cmd}"),
            |pass| {
                let escaped = shell_single_quote(pass);
                format!("printf '%s\\n' {escaped} | sudo -S {base_cmd}")
            },
        )
    } else {
        "echo nothing to install".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::Source;

    #[test]
    /// What: Verify executor command builder creates correct commands without hold tail.
    ///
    /// Inputs:
    /// - Official and AUR packages.
    /// - Optional password.
    /// - Dry-run flag.
    ///
    /// Output:
    /// - Commands without hold tail, suitable for PTY execution.
    ///
    /// Details:
    /// - Ensures commands are properly formatted and don't include terminal hold prompts.
    fn executor_build_install_command_variants() {
        let official_pkg = PackageItem {
            name: "ripgrep".into(),
            version: "14".into(),
            description: String::new(),
            source: Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
            popularity: None,
            out_of_date: None,
            orphaned: false,
        };

        let aur_pkg = PackageItem {
            name: "yay-bin".into(),
            version: "1".into(),
            description: String::new(),
            source: Source::Aur,
            popularity: None,
            out_of_date: None,
            orphaned: false,
        };

        // Official package without password
        let cmd1 =
            build_install_command_for_executor(std::slice::from_ref(&official_pkg), None, false);
        assert!(cmd1.contains("sudo pacman -S --needed --noconfirm ripgrep"));
        assert!(!cmd1.contains("Press any key to close"));

        // Official package with password
        let cmd2 = build_install_command_for_executor(
            std::slice::from_ref(&official_pkg),
            Some("pass"),
            false,
        );
        assert!(cmd2.contains("printf "));
        assert!(cmd2.contains("sudo -S pacman -S --needed --noconfirm ripgrep"));

        // AUR package
        let cmd3 = build_install_command_for_executor(&[aur_pkg], None, false);
        assert!(cmd3.contains("command -v paru"));
        assert!(!cmd3.contains("Press any key to close"));

        // Dry run
        let cmd4 = build_install_command_for_executor(&[official_pkg], None, true);
        assert!(cmd4.starts_with("echo DRY RUN:"));
    }
}
