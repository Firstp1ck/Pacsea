//! PTY-based command executor for in-TUI execution.

use crate::state::{PackageItem, modal::CascadeMode};

/// What: Request types for command execution.
///
/// Inputs:
/// - Various operation types (Install, Remove, etc.) with their parameters.
///
/// Output:
/// - Sent to executor worker to trigger command execution.
///
/// Details:
/// - Each variant contains all necessary information to build and execute the command.
#[derive(Debug, Clone)]
pub enum ExecutorRequest {
    /// Install packages.
    Install {
        /// Packages to install.
        items: Vec<PackageItem>,
        /// Optional sudo password for official packages.
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Remove packages.
    Remove {
        /// Package names to remove.
        names: Vec<String>,
        /// Optional sudo password.
        password: Option<String>,
        /// Cascade removal mode.
        cascade: CascadeMode,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Downgrade packages.
    Downgrade {
        /// Package names to downgrade.
        names: Vec<String>,
        /// Optional sudo password.
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Custom command execution (for special cases like paru/yay installation).
    CustomCommand {
        /// Command string to execute.
        command: String,
        /// Optional sudo password for commands that need sudo (e.g., makepkg -si).
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// System update (mirrors, pacman, AUR, cache).
    Update {
        /// Commands to execute in sequence.
        commands: Vec<String>,
        /// Optional sudo password for commands that need sudo.
        password: Option<String>,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
    /// Security scan for AUR package (excluding aur-sleuth).
    Scan {
        /// Package name to scan.
        package: String,
        /// Scan configuration flags.
        do_clamav: bool,
        /// Trivy scan flag.
        do_trivy: bool,
        /// Semgrep scan flag.
        do_semgrep: bool,
        /// `ShellCheck` scan flag.
        do_shellcheck: bool,
        /// `VirusTotal` scan flag.
        do_virustotal: bool,
        /// Custom pattern scan flag.
        do_custom: bool,
        /// Whether to run in dry-run mode.
        dry_run: bool,
    },
}

/// What: Output messages from command execution.
///
/// Inputs:
/// - Generated by executor worker during command execution.
///
/// Output:
/// - Sent to main event loop for display in `PreflightExec` modal.
///
/// Details:
/// - Line messages contain output from the `PTY`, Finished indicates completion.
#[derive(Debug, Clone)]
pub enum ExecutorOutput {
    /// Output line from command execution.
    Line(String),
    /// Replace the last line (used for progress bars with carriage return).
    ReplaceLastLine(String),
    /// Command execution finished.
    Finished {
        /// Whether execution succeeded.
        success: bool,
        /// Exit code if available.
        exit_code: Option<i32>,
        /// Name of the failed command (if execution failed and this is an update operation).
        failed_command: Option<String>,
    },
    /// Error occurred during execution.
    Error(String),
}

/// What: Build install command string without hold tail for `PTY` execution.
///
/// Inputs:
/// - `items`: Packages to install.
/// - `_password`: Optional sudo password (unused - password is written to PTY stdin when sudo prompts).
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail).
///
/// Details:
/// - Groups official and `AUR` packages separately.
/// - Uses `--noconfirm` for non-interactive execution.
/// - Always uses `sudo -S` for official packages (password written to PTY stdin when sudo prompts).
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_install_command_for_executor(
    items: &[PackageItem],
    password: Option<&str>,
    dry_run: bool,
) -> String {
    use super::command::aur_install_body;
    use super::utils::shell_single_quote;
    use crate::state::Source;

    let mut official: Vec<String> = Vec::new();
    let mut aur: Vec<String> = Vec::new();

    for item in items {
        match item.source {
            Source::Official { .. } => official.push(item.name.clone()),
            Source::Aur => aur.push(item.name.clone()),
        }
    }

    if dry_run {
        if !aur.is_empty() {
            let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
            // Check if any packages are already installed (reinstall scenario)
            // Use comprehensive check that includes packages provided by installed packages
            let installed_set = crate::logic::deps::get_installed_packages();
            let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
            let has_reinstall = items.iter().any(|item| {
                crate::logic::deps::is_package_installed_or_provided(
                    &item.name,
                    &installed_set,
                    &provided_set,
                )
            });
            let flags = if has_reinstall {
                "--noconfirm"
            } else {
                "--needed --noconfirm"
            };
            let cmd = format!(
                "(paru -S {flags} {n} || yay -S {flags} {n})",
                n = all.join(" "),
                flags = flags
            );
            let quoted = shell_single_quote(&cmd);
            format!("echo DRY RUN: {quoted}")
        } else if !official.is_empty() {
            // Check if any packages are already installed (reinstall scenario)
            // Use comprehensive check that includes packages provided by installed packages
            let installed_set = crate::logic::deps::get_installed_packages();
            let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
            let has_reinstall = official.iter().any(|name| {
                crate::logic::deps::is_package_installed_or_provided(
                    name,
                    &installed_set,
                    &provided_set,
                )
            });
            let flags = if has_reinstall {
                "--noconfirm"
            } else {
                "--needed --noconfirm"
            };
            let cmd = format!(
                "sudo pacman -S {flags} {n}",
                n = official.join(" "),
                flags = flags
            );
            let quoted = shell_single_quote(&cmd);
            format!("echo DRY RUN: {quoted}")
        } else {
            "echo DRY RUN: nothing to install".to_string()
        }
    } else if !aur.is_empty() {
        let all: Vec<String> = items.iter().map(|p| p.name.clone()).collect();
        let n = all.join(" ");
        // Check if any packages are already installed (reinstall scenario)
        // Use comprehensive check that includes packages provided by installed packages
        let installed_set = crate::logic::deps::get_installed_packages();
        let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
        let has_reinstall = items.iter().any(|item| {
            crate::logic::deps::is_package_installed_or_provided(
                &item.name,
                &installed_set,
                &provided_set,
            )
        });
        let flags = if has_reinstall {
            "-S --noconfirm"
        } else {
            "-S --needed --noconfirm"
        };
        aur_install_body(flags, &n)
    } else if !official.is_empty() {
        // Check if any packages are already installed (reinstall scenario)
        // Use comprehensive check that includes packages provided by installed packages
        let installed_set = crate::logic::deps::get_installed_packages();
        let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
        let has_reinstall = official.iter().any(|name| {
            crate::logic::deps::is_package_installed_or_provided(
                name,
                &installed_set,
                &provided_set,
            )
        });
        let flags = if has_reinstall {
            "--noconfirm"
        } else {
            "--needed --noconfirm"
        };
        // Sync database first (pacman -Sy) to ensure latest versions are available,
        // then install the packages
        let install_cmd = format!("pacman -S {flags} {}", official.join(" "));
        // Use printf to pipe password to sudo -S (more reliable than echo)
        password.map_or_else(
            || format!("sudo pacman -Sy && sudo {install_cmd}"),
            |pass| {
                let escaped = shell_single_quote(pass);
                // Sync first, then install - use single password for both
                format!("printf '%s\\n' {escaped} | sudo -S pacman -Sy && printf '%s\\n' {escaped} | sudo -S {install_cmd}")
            },
        )
    } else {
        "echo nothing to install".to_string()
    }
}

/// What: Build remove command string without hold tail for `PTY` execution.
///
/// Inputs:
/// - `names`: Package names to remove.
/// - `password`: Optional sudo password (password is written to PTY stdin when sudo prompts).
/// - `cascade`: Cascade removal mode.
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail).
///
/// Details:
/// - Uses `-R`, `-Rs`, or `-Rns` based on cascade mode.
/// - Uses `--noconfirm` for non-interactive execution.
/// - Always uses `sudo -S` for remove operations (password written to PTY stdin when sudo prompts).
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_remove_command_for_executor(
    names: &[String],
    password: Option<&str>,
    cascade: crate::state::modal::CascadeMode,
    dry_run: bool,
) -> String {
    use super::utils::shell_single_quote;

    if names.is_empty() {
        return if dry_run {
            "echo DRY RUN: nothing to remove".to_string()
        } else {
            "echo nothing to remove".to_string()
        };
    }

    let flag = cascade.flag();
    let names_str = names.join(" ");

    if dry_run {
        let cmd = format!("sudo pacman {flag} --noconfirm {names_str}");
        let quoted = shell_single_quote(&cmd);
        format!("echo DRY RUN: {quoted}")
    } else {
        let base_cmd = format!("pacman {flag} --noconfirm {names_str}");
        // Use printf to pipe password to sudo -S (more reliable than echo)
        password.map_or_else(
            || format!("sudo {base_cmd}"),
            |pass| {
                let escaped = shell_single_quote(pass);
                format!("printf '%s\\n' {escaped} | sudo -S {base_cmd}")
            },
        )
    }
}

/// What: Build downgrade command string without hold tail for `PTY` execution.
///
/// Inputs:
/// - `names`: Package names to downgrade.
/// - `_password`: Optional sudo password (unused - password is written to PTY stdin when sudo prompts).
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail).
///
/// Details:
/// - Uses the `downgrade` tool to downgrade packages.
/// - Checks if `downgrade` tool is available before executing.
/// - Password is written to PTY stdin when sudo prompts, so we don't need to pipe it here.
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_downgrade_command_for_executor(
    names: &[String],
    _password: Option<&str>,
    dry_run: bool,
) -> String {
    use super::utils::shell_single_quote;
    if names.is_empty() {
        return if dry_run {
            "echo DRY RUN: nothing to downgrade".to_string()
        } else {
            "echo nothing to downgrade".to_string()
        };
    }

    let names_str = names.join(" ");

    if dry_run {
        let cmd = format!("sudo downgrade {names_str}");
        let quoted = shell_single_quote(&cmd);
        format!("echo DRY RUN: {quoted}")
    } else {
        // Check if downgrade tool is available, then execute
        // Note: The check uses sudo but password will be written to PTY stdin when sudo prompts
        let base_cmd = format!(
            "if (command -v downgrade >/dev/null 2>&1) || sudo pacman -Qi downgrade >/dev/null 2>&1; then sudo downgrade {names_str}; else echo 'downgrade tool not found. Install \"downgrade\" package.'; fi"
        );
        // Password is written to PTY stdin when sudo prompts, so we don't need to pipe it here
        // Just return the command as-is
        base_cmd
    }
}

/// What: Build system update command string by chaining multiple commands.
///
/// Inputs:
/// - `commands`: List of commands to execute in sequence.
/// - `password`: Optional sudo password for commands that need sudo.
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (commands chained with `&&`).
///
/// Details:
/// - Chains commands with `&&` so execution stops on first failure.
/// - For commands starting with `sudo`, pipes password if provided.
/// - In dry-run mode, wraps each command in `echo DRY RUN:`.
/// - Removes hold tail since we're not spawning a terminal.
#[must_use]
pub fn build_update_command_for_executor(
    commands: &[String],
    password: Option<&str>,
    dry_run: bool,
) -> String {
    use super::utils::shell_single_quote;

    if commands.is_empty() {
        return if dry_run {
            "echo DRY RUN: nothing to update".to_string()
        } else {
            "echo nothing to update".to_string()
        };
    }

    let processed_commands: Vec<String> = if dry_run {
        // Check if we should simulate failure for testing (first command only, if it's pacman)
        let simulate_failure = std::env::var("PACSEA_TEST_SIMULATE_PACMAN_FAILURE").is_ok()
            && !commands.is_empty()
            && commands[0].contains("pacman");

        if simulate_failure {
            tracing::info!(
                "[DRY-RUN] Simulating pacman failure for testing - first command will fail with exit code 1"
            );
        }

        commands
            .iter()
            .enumerate()
            .map(|(idx, c)| {
                // Properly quote the command to avoid syntax errors with complex shell constructs
                let quoted = shell_single_quote(c);
                if simulate_failure && idx == 0 {
                    // Simulate pacman failure for testing confirmation popup
                    // Use false to ensure the command fails with exit code 1
                    // The && will prevent subsequent commands from running
                    format!("echo DRY RUN: {quoted} && false")
                } else {
                    format!("echo DRY RUN: {quoted}")
                }
            })
            .collect()
    } else {
        commands
            .iter()
            .map(|cmd| {
                // Check if command needs sudo and has password
                password.map_or_else(
                    || cmd.clone(),
                    |pass| {
                        if cmd.starts_with("sudo ") {
                            // Extract the command after "sudo "
                            let base_cmd = cmd.strip_prefix("sudo ").unwrap_or(cmd);
                            let escaped = shell_single_quote(pass);
                            format!("printf '%s\\n' {escaped} | sudo -S {base_cmd}")
                        } else {
                            // Command doesn't need password or already has it handled
                            cmd.clone()
                        }
                    },
                )
            })
            .collect()
    };

    let joined = processed_commands.join(" && ");

    // If password is provided and any command contains "sudo", cache credentials first
    // This handles cases where sudo is called inside shell scripts (like mirror update)
    // that don't start with "sudo " but contain sudo calls internally
    if let Some(pass) = password {
        let has_sudo_anywhere = commands.iter().any(|c| c.contains("sudo"));
        if has_sudo_anywhere {
            let escaped = shell_single_quote(pass);
            // Cache sudo credentials first using sudo -v, then run the commands
            // Using `;` ensures commands run even if credential caching has issues
            return format!("printf '%s\\n' {escaped} | sudo -S -v 2>/dev/null ; {joined}");
        }
    }

    joined
}

/// What: Build scan command string for `PTY` execution (excluding aur-sleuth).
///
/// Inputs:
/// - `package`: Package name to scan.
/// - `do_clamav`/`do_trivy`/`do_semgrep`/`do_shellcheck`/`do_virustotal`/`do_custom`: Scan configuration flags.
/// - `dry_run`: Whether to run in dry-run mode.
///
/// Output:
/// - Command string ready for `PTY` execution (no hold tail, excludes aur-sleuth).
///
/// Details:
/// - Builds scan pipeline commands excluding aur-sleuth (which runs separately in terminal).
/// - Sets environment variables for scan configuration.
/// - Removes hold tail since we're not spawning a terminal.
#[cfg(not(target_os = "windows"))]
#[must_use]
#[allow(clippy::fn_params_excessive_bools, clippy::too_many_arguments)]
pub fn build_scan_command_for_executor(
    package: &str,
    do_clamav: bool,
    do_trivy: bool,
    do_semgrep: bool,
    do_shellcheck: bool,
    do_virustotal: bool,
    do_custom: bool,
    dry_run: bool,
) -> String {
    use super::utils::shell_single_quote;
    use crate::install::scan::pkg::build_scan_cmds_for_pkg_without_sleuth;

    // Prepend environment exports so subsequent steps honor the selection
    let mut cmds: Vec<String> = Vec::new();
    cmds.push(format!(
        "export PACSEA_SCAN_DO_CLAMAV={}",
        if do_clamav { "1" } else { "0" }
    ));
    cmds.push(format!(
        "export PACSEA_SCAN_DO_TRIVY={}",
        if do_trivy { "1" } else { "0" }
    ));
    cmds.push(format!(
        "export PACSEA_SCAN_DO_SEMGREP={}",
        if do_semgrep { "1" } else { "0" }
    ));
    cmds.push(format!(
        "export PACSEA_SCAN_DO_SHELLCHECK={}",
        if do_shellcheck { "1" } else { "0" }
    ));
    cmds.push(format!(
        "export PACSEA_SCAN_DO_VIRUSTOTAL={}",
        if do_virustotal { "1" } else { "0" }
    ));
    cmds.push(format!(
        "export PACSEA_SCAN_DO_CUSTOM={}",
        if do_custom { "1" } else { "0" }
    ));
    // Export default pattern sets
    cmds.push("export PACSEA_PATTERNS_CRIT='/dev/(tcp|udp)/|bash -i *>& *[^ ]*/dev/(tcp|udp)/[0-9]+|exec [0-9]{2,}<>/dev/(tcp|udp)/|rm -rf[[:space:]]+/|dd if=/dev/zero of=/dev/sd[a-z]|[>]{1,2}[[:space:]]*/dev/sd[a-z]|: *\\(\\) *\\{ *: *\\| *: *& *\\};:|/etc/sudoers([[:space:]>]|$)|echo .*[>]{2}.*(/etc/sudoers|/root/.ssh/authorized_keys)|/etc/ld\\.so\\.preload|LD_PRELOAD=|authorized_keys.*[>]{2}|ssh-rsa [A-Za-z0-9+/=]+.*[>]{2}.*authorized_keys|curl .*(169\\.254\\.169\\.254)'".to_string());
    cmds.push("export PACSEA_PATTERNS_HIGH='eval|base64 -d|wget .*(sh|bash|dash|ksh|zsh)([^A-Za-z]|$)|curl .*(sh|bash|dash|ksh|zsh)([^A-Za-z]|$)|sudo[[:space:]]|chattr[[:space:]]|useradd|adduser|groupadd|systemctl|service[[:space:]]|crontab|/etc/cron\\.|[>]{2}.*(\\.bashrc|\\.bash_profile|/etc/profile|\\.zshrc)|cat[[:space:]]+/etc/shadow|cat[[:space:]]+~/.ssh/id_rsa|cat[[:space:]]+~/.bash_history|systemctl stop (auditd|rsyslog)|service (auditd|rsyslog) stop|scp .*@|curl -F|nc[[:space:]].*<|tar -czv?f|zip -r'".to_string());
    cmds.push("export PACSEA_PATTERNS_MEDIUM='whoami|uname -a|hostname|id|groups|nmap|netstat -anp|ss -anp|ifconfig|ip addr|arp -a|grep -ri .*secret|find .*-name.*(password|\\.key)|env[[:space:]]*\\|[[:space:]]*grep -i pass|wget https?://|curl https?://'".to_string());
    cmds.push("export PACSEA_PATTERNS_LOW='http_proxy=|https_proxy=|ALL_PROXY=|yes[[:space:]]+> */dev/null *&|ulimit -n [0-9]{5,}'".to_string());

    // Append the scan pipeline commands (excluding sleuth)
    cmds.extend(build_scan_cmds_for_pkg_without_sleuth(package));

    let full_cmd = cmds.join(" && ");

    if dry_run {
        let quoted = shell_single_quote(&full_cmd);
        format!("echo DRY RUN: {quoted}")
    } else {
        full_cmd
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::Source;

    /// What: Create a test package item with specified source.
    ///
    /// Inputs:
    /// - `name`: Package name
    /// - `source`: Package source (Official or AUR)
    ///
    /// Output:
    /// - `PackageItem` ready for testing
    ///
    /// Details:
    /// - Helper to create test packages with consistent structure
    fn create_test_package(name: &str, source: Source) -> PackageItem {
        PackageItem {
            name: name.into(),
            version: "1.0.0".into(),
            description: String::new(),
            source,
            popularity: None,
            out_of_date: None,
            orphaned: false,
        }
    }

    #[test]
    /// What: Verify executor command builder creates correct commands without hold tail.
    ///
    /// Inputs:
    /// - Official and AUR packages.
    /// - Optional password.
    /// - Dry-run flag.
    ///
    /// Output:
    /// - Commands without hold tail, suitable for PTY execution.
    ///
    /// Details:
    /// - Ensures commands are properly formatted and don't include terminal hold prompts.
    fn executor_build_install_command_variants() {
        let official_pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        let aur_pkg = create_test_package("yay-bin", Source::Aur);

        // Official package without password
        // Check if package is installed to determine expected flags
        let installed_set = crate::logic::deps::get_installed_packages();
        let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
        let is_installed = crate::logic::deps::is_package_installed_or_provided(
            "ripgrep",
            &installed_set,
            &provided_set,
        );
        let cmd1 =
            build_install_command_for_executor(std::slice::from_ref(&official_pkg), None, false);
        if is_installed {
            // If installed, should use only --noconfirm
            assert!(cmd1.contains("sudo pacman -S --noconfirm ripgrep"));
            assert!(!cmd1.contains("--needed"));
        } else {
            // If not installed, should use --needed --noconfirm
            assert!(cmd1.contains("sudo pacman -S --needed --noconfirm ripgrep"));
        }
        assert!(!cmd1.contains("Press any key to close"));

        // Official package with password
        let cmd2 = build_install_command_for_executor(
            std::slice::from_ref(&official_pkg),
            Some("pass"),
            false,
        );
        assert!(cmd2.contains("printf "));
        if is_installed {
            // If installed, should use only --noconfirm
            assert!(cmd2.contains("sudo -S pacman -S --noconfirm ripgrep"));
            assert!(!cmd2.contains("--needed"));
        } else {
            // If not installed, should use --needed --noconfirm
            assert!(cmd2.contains("sudo -S pacman -S --needed --noconfirm ripgrep"));
        }

        // AUR package
        let cmd3 = build_install_command_for_executor(std::slice::from_ref(&aur_pkg), None, false);
        assert!(cmd3.contains("command -v paru"));
        assert!(!cmd3.contains("Press any key to close"));

        // Dry run
        let cmd4 = build_install_command_for_executor(&[official_pkg], None, true);
        assert!(cmd4.starts_with("echo DRY RUN:"));
    }

    #[test]
    /// What: Verify command builder handles mixed official and AUR packages.
    ///
    /// Inputs:
    /// - Mixed list of official and AUR packages.
    ///
    /// Output:
    /// - Command that installs all packages using appropriate tool.
    ///
    /// Details:
    /// - When AUR packages are present, command should use AUR helper for all packages.
    fn executor_build_mixed_packages() {
        let official_pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );
        let aur_pkg = create_test_package("yay-bin", Source::Aur);

        let cmd = build_install_command_for_executor(&[official_pkg, aur_pkg], None, false);
        // When AUR packages are present, should use AUR helper
        assert!(cmd.contains("command -v paru") || cmd.contains("command -v yay"));
    }

    #[test]
    /// What: Verify command builder handles empty package list.
    ///
    /// Inputs:
    /// - Empty package list.
    ///
    /// Output:
    /// - Command that indicates nothing to install.
    ///
    /// Details:
    /// - Empty list should produce a safe no-op command.
    fn executor_build_empty_list() {
        let cmd = build_install_command_for_executor(&[], None, false);
        assert!(cmd.contains("nothing to install") || cmd.is_empty());
    }

    #[test]
    /// What: Verify command builder handles multiple official packages.
    ///
    /// Inputs:
    /// - Multiple official packages.
    ///
    /// Output:
    /// - Command that installs all packages via pacman.
    ///
    /// Details:
    /// - Multiple packages should be space-separated in the command.
    fn executor_build_multiple_official() {
        let pkg1 = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );
        let pkg2 = create_test_package(
            "fd",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        // Check if packages are installed to determine expected flags
        let installed_set = crate::logic::deps::get_installed_packages();
        let provided_set = crate::logic::deps::get_provided_packages(&installed_set);
        let ripgrep_installed = crate::logic::deps::is_package_installed_or_provided(
            "ripgrep",
            &installed_set,
            &provided_set,
        );
        let fd_installed = crate::logic::deps::is_package_installed_or_provided(
            "fd",
            &installed_set,
            &provided_set,
        );
        let has_reinstall = ripgrep_installed || fd_installed;

        let cmd = build_install_command_for_executor(&[pkg1, pkg2], None, false);
        assert!(cmd.contains("ripgrep"));
        assert!(cmd.contains("fd"));
        if has_reinstall {
            // If any package is installed, should use only --noconfirm
            assert!(cmd.contains("pacman -S --noconfirm"));
            assert!(!cmd.contains("--needed"));
        } else {
            // If no packages are installed, should use --needed --noconfirm
            assert!(cmd.contains("pacman -S --needed --noconfirm"));
        }
    }

    #[test]
    /// What: Verify dry-run mode produces echo commands.
    ///
    /// Inputs:
    /// - Package list with `dry_run=true`.
    ///
    /// Output:
    /// - Command that starts with "echo DRY RUN:".
    ///
    /// Details:
    /// - Dry-run should never execute actual install commands.
    fn executor_build_dry_run() {
        let pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        let cmd = build_install_command_for_executor(&[pkg], None, true);
        assert!(cmd.starts_with("echo DRY RUN:"));
        // In dry-run mode, the command is wrapped in echo, so it may contain the original command text
        // The important thing is that it starts with "echo DRY RUN:" which prevents execution
    }

    #[test]
    /// What: Verify password is properly escaped in command.
    ///
    /// Inputs:
    /// - Official package with password containing special characters.
    ///
    /// Output:
    /// - Command with properly escaped password.
    ///
    /// Details:
    /// - Password should be single-quoted to prevent shell injection.
    fn executor_build_password_escaping() {
        let pkg = create_test_package(
            "ripgrep",
            Source::Official {
                repo: "extra".into(),
                arch: "x86_64".into(),
            },
        );

        // Password with special characters
        let password = "pass'word\"with$special";
        let cmd = build_install_command_for_executor(&[pkg], Some(password), false);
        assert!(cmd.contains("printf"));
        assert!(cmd.contains("sudo -S"));
        // Password should be properly quoted
        assert!(cmd.contains('\'') || cmd.contains('"'));
    }

    #[test]
    /// What: Verify remove command builder creates correct commands without hold tail.
    ///
    /// Inputs:
    /// - Package names, cascade mode, optional password, dry-run flag.
    ///
    /// Output:
    /// - Commands without hold tail, suitable for PTY execution.
    ///
    /// Details:
    /// - Ensures commands are properly formatted and don't include terminal hold prompts.
    fn executor_build_remove_command_variants() {
        use crate::state::modal::CascadeMode;

        let names = vec!["test-pkg1".to_string(), "test-pkg2".to_string()];

        // Basic mode without password
        let cmd1 = build_remove_command_for_executor(&names, None, CascadeMode::Basic, false);
        assert!(cmd1.contains("sudo pacman -R --noconfirm"));
        assert!(cmd1.contains("test-pkg1"));
        assert!(cmd1.contains("test-pkg2"));
        assert!(!cmd1.contains("Press any key to close"));

        // Cascade mode with password
        let cmd2 =
            build_remove_command_for_executor(&names, Some("pass"), CascadeMode::Cascade, false);
        assert!(cmd2.contains("printf "));
        assert!(cmd2.contains("sudo -S pacman -Rs --noconfirm"));

        // CascadeWithConfigs mode
        let cmd3 =
            build_remove_command_for_executor(&names, None, CascadeMode::CascadeWithConfigs, false);
        assert!(cmd3.contains("sudo pacman -Rns --noconfirm"));

        // Dry run
        let cmd4 = build_remove_command_for_executor(&names, None, CascadeMode::Basic, true);
        assert!(cmd4.starts_with("echo DRY RUN:"));
        assert!(cmd4.contains("pacman -R --noconfirm"));

        // Empty list
        let cmd5 = build_remove_command_for_executor(&[], None, CascadeMode::Basic, false);
        assert_eq!(cmd5, "echo nothing to remove");
    }
}
